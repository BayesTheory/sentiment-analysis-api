NEXT_STEPS — Sentiment API (Poetry + Docker + Cloud Run)

OBJETIVO 1 (MVP): rodar local + rodar no Docker + deploy no Cloud Run.

[1] Fixar Python alvo
- Escolher Python 3.12 (recomendado) para maximizar compatibilidade de wheels.
- Garantir que o Poetry use esse Python (poetry env use ...).

[2] Migrar dependências para Poetry
- Criar pyproject.toml + poetry.lock.
- Separar deps de dev (pytest) em group dev.
- Comandos base:
  - poetry add fastapi uvicorn[standard] pydantic pydantic-settings transformers torch python-dotenv httpx
  - poetry add --group dev pytest
  - poetry lock
  - poetry install

Notas:
- O lockfile (poetry.lock) garante reprodutibilidade do ambiente. 

[3] Rodar local (sem Docker)
- poetry run uvicorn app.main:app --reload --port 8000
- Testes:
  - curl http://localhost:8000/health
  - curl -X POST http://localhost:8000/predict -H "Content-Type: application/json" -d "{\"text\":\"Adorei\",\"lang\":\"pt\"}"

[4] Dockerizar com Poetry (imagem de produção)
- Dockerfile deve copiar primeiro pyproject.toml e poetry.lock (para cache) e instalar só deps main.
- Usar:
  - poetry install --only main --no-root
- Build/run:
  - docker build -t sentiment-api:local .
  - docker run -p 8000:8000 sentiment-api:local
- Repetir os curls do passo [3].

[5] Cloud Run (deploy do MVP)
- Build e deploy:
  - gcloud builds submit --tag gcr.io/PROJECT_ID/sentiment-api:v1
  - gcloud run deploy sentiment-api --image gcr.io/PROJECT_ID/sentiment-api:v1 --region us-central1 --memory 512Mi --timeout 60 --allow-unauthenticated
- Testar /health e /predict na URL pública.

------------------------------------------------------------
OBJETIVO 2 (PORTFÓLIO): coisas "mostráveis" para empresa.

[6] Observabilidade básica (primeiro o mínimo)
- Logs JSON estruturados por request (request_id, status_code, latency_ms, model_version).
- Adicionar endpoint /metrics (Prometheus).
- Definir 4 métricas “de produto”: throughput, p95 latência, erro 5xx, tempo de inferência.

[7] Dashboard (demo visual)
- Criar um app separado (Streamlit ou Gradio) que chama a API /predict.
- Mostrar:
  - input text
  - label/score
  - tempo de inferência
  - histórico das últimas inferências
- Publicar UI em link público (ideal) + API no Cloud Run.

[8] CI/CD e qualidade
- GitHub Actions:
  - lint (opcional)
  - testes (pytest)
  - build docker
  - deploy (se quiser)
- “Badge” no README: tests passing.

[9] Documentação de engenharia (README)
- Architecture (1 diagrama simples)
- Decisions (por que FastAPI, por que Poetry, por que Cloud Run)
- SLO alvo (ex.: p95 do /predict) + como monitorar
- Runbook: “se der 500, veja logs X; se latência subir, veja memória/cold start”

PRONTO: quando [1]-[5] estiverem OK, o projeto já vale como “produção”.
